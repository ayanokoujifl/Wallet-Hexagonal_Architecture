# üèõÔ∏è Guia de Arquitetura: Clean Architecture & Hexagonal

Este projeto segue os princ√≠pios da **Clean Architecture** (Robert C. Martin) e **Arquitetura Hexagonal** (Ports and Adapters). O objetivo principal √© proteger as Regras de Neg√≥cio (Dom√≠nio) de mudan√ßas em tecnologias externas (Banco de Dados, Frameworks, UI).

## üìÇ Estrutura de Pastas e Responsabilidades

### 1. `domain` (O N√∫cleo / Core)
> **Regra de Ouro:** Aqui s√≥ entra **Java Puro**. Proibido importar bibliotecas externas, Spring, Hibernate ou qualquer framework.

* **`model`**: As Entidades de Neg√≥cio. Diferente das entidades do banco, estas s√£o ricas em comportamento e validam a si mesmas.
    * *Ex:* `Carteira.java` (cont√©m a l√≥gica de `creditar`, valida `saldo`).
* **`ports`**: As Interfaces (Contratos). Definem como o mundo externo interage com o n√∫cleo.
    * **`input`**: O que o sistema sabe fazer (Casos de Uso). *Ex:* `CriarCarteiraUseCase`.
    * **`output`**: O que o sistema precisa que fa√ßam por ele (Acesso a dados). *Ex:* `CarteiraRepositoryPort`.
* **`usecase`**: A orquestra√ß√£o. Implementa os `ports.input`. Pega uma entidade, aplica regras e chama um `port.output` para salvar.

---

### 2. `infrastructure` (Os Detalhes / Adapters)
> **Regra:** Aqui vive tudo aquilo que "suja" o c√≥digo: Banco de Dados, APIs Externas, Ferramentas de Log, etc.

* **`persistence`**: Tudo relacionado a Banco de Dados.
    * **`entity`**: O espelho do banco (`@Entity`, `@Table`). √â an√™mica (s√≥ dados).
    * **`repository`**: Interface do Spring Data (`JpaRepository`).
    * **`mapper`**: Converte `Domain Model` ‚Üî `Persistence Entity`. Garante que o Dom√≠nio nunca toque no JPA.
    * **`Gateway`**: Implementa o `port.output` do dom√≠nio. √â a ponte real entre o Core e o Banco.

---

### 3. `application` (A Configura√ß√£o e Entrada)
> **Regra:** √â a "cola" que une o Spring Boot ao nosso Dom√≠nio agn√≥stico.

* **`controller`**: Pontos de entrada REST (`@RestController`). Recebe JSON (DTOs), converte e chama o Caso de Uso.
* **`config`**: Onde a Inje√ß√£o de Depend√™ncia manual acontece (`@Configuration`).
    * Aqui instanciamos os UseCases (`new CriarCarteiraUseCaseImpl(...)`) e os entregamos ao Spring. Isso nos d√° controle total sobre qual implementa√ß√£o usar.

---

## üîÑ Fluxo de Dados (Request Lifecycle)

Quando um usu√°rio envia um POST para criar uma carteira, o dado viaja assim:

1.  **Mundo Externo (HTTP)**: O JSON chega no `CarteiraController`.
2.  **DTO**: O Controller converte o JSON para um `Record` Java.
3.  **Fronteira de Entrada**: O Controller chama `useCase.criar()`.
4.  **N√∫cleo (Domain)**:
    * O `UseCase` instancia a Entidade `Carteira`.
    * A `Carteira` valida suas regras (ex: saldo inicial zero).
    * O `UseCase` pede para salvar chamando a porta `repositoryPort.salvar()`.
5.  **Fronteira de Sa√≠da**: O `CarteiraRepositoryGateway` (Infra) intercepta a chamada.
6.  **Mapper**: O Gateway usa o Mapper para converter `Carteira` (Limpa) em `CarteiraEntity` (Suja).
7.  **Banco de Dados**: O `JpaRepository` salva a tabela.
8.  **Retorno**: O processo se inverte (Mapper ‚Üí Domain ‚Üí UseCase ‚Üí Controller ‚Üí JSON).

## üí° Por que fazer isso?

1.  **Testabilidade**: Podemos testar o `domain` inteiro sem ligar o Spring ou o Banco de Dados.
2.  **Prote√ß√£o**: Se trocarmos MySQL por MongoDB, o `domain` nem fica sabendo. S√≥ mudamos a pasta `infrastructure`.
3.  **Manutenibilidade**: Um bug de regra de neg√≥cio SEMPRE estar√° no `domain`. Um bug de SQL SEMPRE estar√° na `infrastructure`.